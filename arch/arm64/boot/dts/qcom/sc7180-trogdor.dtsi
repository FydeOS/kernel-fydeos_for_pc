// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
/*
 * Google Trogdor device tree source (common between revisions)
 *
 * Copyright 2019 Google LLC.
 */

#include <dt-bindings/gpio/gpio.h>
#include <dt-bindings/input/input.h>
#include <dt-bindings/regulator/qcom,rpmh-regulator.h>

/* PMICs depend on spmi_bus label and so must come after SoC */
#include "pm6150.dtsi"
#include "pm6150l.dtsi"

/ {
	aliases {
		hsuart0 = &uart3;
		serial0 = &uart8;
	};

	chosen {
		stdout-path = "serial0:115200n8";
	};

	/* FIXED REGULATORS - parents above children */

	/* This is the top level supply and variable voltage */
	ppvar_sys: ppvar-sys-regulator {
		compatible = "regulator-fixed";
		regulator-name = "ppvar_sys";
		regulator-always-on;
		regulator-boot-on;
	};

	/* This divides ppvar_sys by 2, so voltage is variable */
	src_vph_pwr: src-vph-pwr-regulator {
		compatible = "regulator-fixed";
		regulator-name = "src_vph_pwr";

		/* EC turns on with switchcap_on; always on for AP */
		regulator-always-on;
		regulator-boot-on;

		vin-supply = <&ppvar_sys>;
	};

	pp1200_brij: pp1200-brij-regulator {
		compatible = "regulator-fixed";
		regulator-name = "pp1200_brij";

		regulator-min-microvolt = <1200000>;
		regulator-max-microvolt = <1200000>;

		gpio = <&tlmm 30 GPIO_ACTIVE_HIGH>;
		enable-active-high;
		pinctrl-names = "default";
		pinctrl-0 = <&brij_pp1200_en>;
	};

	pp5000_a: pp5000-a-regulator {
		compatible = "regulator-fixed";
		regulator-name = "pp5000_a";

		/* EC turns on with en_pp5000_a; always on for AP */
		regulator-always-on;
		regulator-boot-on;
		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;

		vin-supply = <&ppvar_sys>;
	};

	pp3300_audio:
	pp3300_codec: pp3300-codec-regulator {
		compatible = "regulator-fixed";
		regulator-name = "pp3300_codec";

		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;

		gpio = <&tlmm 83 GPIO_ACTIVE_HIGH>;
		enable-active-high;
		pinctrl-names = "default";
		pinctrl-0 = <&en_pp3300_codec>;
	};

	pp3300_dx_edp:
	pp3300_ts: pp3300-dx-edp-regulator {
		compatible = "regulator-fixed";
		regulator-name = "pp3300_dx_edp";

		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;

		gpio = <&tlmm 106 GPIO_ACTIVE_HIGH>;
		enable-active-high;
		pinctrl-names = "default";
		pinctrl-0 = <&en_pp3300_dx_edp>;
	};

	pp3300_fp_tp: pp3300-fp-tp-regulator {
		compatible = "regulator-fixed";
		regulator-name = "pp3300_fp_tp";

		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;

		/* AP turns on with PP1800_VIO_OUT; always on for AP */
		regulator-always-on;
		regulator-boot-on;
	};

	/* BOARD-SPECIFIC TOP LEVEL NODES */

	backlight: backlight {
		compatible = "pwm-backlight";
		pwms = <&cros_ec_pwm 1>;
		enable-gpios = <&tlmm 12 GPIO_ACTIVE_HIGH>;
		power-supply = <&ppvar_sys>;
		pinctrl-names = "default";
		pinctrl-0 = <&ap_edp_bklten>;
	};

	panel: panel {
		compatible = "auo,b116xa01";
		power-supply = <&pp3300_dx_edp>;
		backlight = <&backlight>;
		no-hpd; /*TODO: Evaluate hpd */

		ports {
			port {
				panel_in_edp: endpoint {
					remote-endpoint = <&sn65dsi86_out>;
				};
			};
		};
	};
};

&qspi {
	status = "okay";
	pinctrl-names = "default";
	pinctrl-0 = <&qspi_clk>, <&qspi_cs0>, <&qspi_data01>;

	flash@0 {
		compatible = "jedec,spi-nor";
		reg = <0>;

		/* TODO: Increase frequency after testing */
		spi-max-frequency = <25000000>;
		spi-tx-bus-width = <2>;
		spi-rx-bus-width = <2>;
	};
};


&apps_rsc {
	pm6150-rpmh-regulators {
		compatible = "qcom,pm6150-rpmh-regulators";
		qcom,pmic-id = "a";

		vddpx_1:
		vdd2:
		pp1125_s1a: smps1 {
			regulator-min-microvolt = <1128000>;
			regulator-max-microvolt = <1128000>;
		};

		/*
		 * pp2040_s5a (smps5) and pp1056_s4a (smps4) are just
		 * inputs to other rails on AOP-managed PMICs on trogdor.
		 * The system is already configured to manage these rails
		 * automatically (enable when needed, adjust voltage for
		 * headroom) so we won't specify anything here.
		 *
		 * NOTE: though the rails have a voltage implied by their
		 * name, the automatic headroom calculation might not result
		 * in them being that voltage.  ...and that's OK.
		 * Specifically the only point of these rails is to provide
		 * an input source for other rails and if we can satisify the
		 * needs of those other rails with a lower source voltage then
		 * we save power.
		 */

		pp1200_l1a: ldo1 {
			regulator-min-microvolt = <1200000>;
			regulator-max-microvolt = <1200000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
		};

		pp1000_l2a: ldo2 {
			/* TODO: not ppvar, so min/max should be the same */
			regulator-min-microvolt = <944000>;
			regulator-max-microvolt = <1056000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
		};

		pp1000_l3a: ldo3 {
			/* TODO: not ppvar, so min/max should be the same */
			regulator-min-microvolt = <968000>;
			regulator-max-microvolt = <1064000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
		};

		vdd_qlink_lv:
		vdd_qlink_lv_ck:
		vdd_qusb_hs0_core:
		vdd_ufs1_core:
		vdda_mipi_csi0_0p9:
		vdda_mipi_csi1_0p9:
		vdda_mipi_csi2_0p9:
		vdda_mipi_csi3_0p9:
		vdda_mipi_dsi0_pll:
		vdda_pll_cc_ebi01:
		vdda_qrefs_0p9:
		vdda_usb_ss_dp_core:
		pp900_l4a: ldo4 {
			/* TODO: not ppvar, so min/max should be the same */
			regulator-min-microvolt = <824000>;
			regulator-max-microvolt = <928000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
		};

		pp2700_l5a: ldo5 {
			regulator-min-microvolt = <2704000>;
			regulator-max-microvolt = <2704000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
		};

		ebi0_cal:
		ebi1_cal:
		vddio_ck_ebi0:
		vddio_ck_ebi1:
		vddio_ebi0:
		vddq:
		pp600_l6a: ldo6 {
			/* TODO: not ppvar, so min/max should be the same */
			regulator-min-microvolt = <568000>;
			regulator-max-microvolt = <648000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
		};

		vdd_cx_wlan:
		pp800_l9a: ldo9 {
			/* TODO: not ppvar, so min/max should be the same */
			regulator-min-microvolt = <488000>;
			regulator-max-microvolt = <800000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
		};

		vdd1:
		vddpx_3:
		vddpx_7:
		vio_in:
		pp1800_l10a: ldo10 {
			regulator-min-microvolt = <1800000>;
			regulator-max-microvolt = <1800000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
		};

		vdd_qfprom:
		vdda_apc1_cs_1p8:
		vdda_qrefs_1p8:
		vdda_qusb_hs0_1p8:
		vddpx_11:
		vreg_bb_clk:
		pp1800_l11a: ldo11 {
			regulator-min-microvolt = <1800000>;
			regulator-max-microvolt = <1800000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
		};

		mcp_vccq:
		pp1800_l12a_r: ldo12 {
			regulator-min-microvolt = <1800000>;
			regulator-max-microvolt = <1800000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
		};

		pp1800_l13a: ldo13 {
			regulator-min-microvolt = <1800000>;
			regulator-max-microvolt = <1800000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
		};

		pp1800_prox:
		pp1800_l14a: ldo14 {
			regulator-min-microvolt = <1800000>;
			regulator-max-microvolt = <1800000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
		};

		pp1800_alc5682:
		pp1800_l15a: ldo15 {
			regulator-min-microvolt = <1800000>;
			regulator-max-microvolt = <1800000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
			/* TODO: figre out when to turn this off */
			regulator-always-on;
			regulator-boot-on;
		};

		pp2700_l16a: ldo16 {
			/* TODO: not ppvar, so min/max should be the same */
			regulator-min-microvolt = <2496000>;
			regulator-max-microvolt = <3304000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
		};

		vdda_qusb_hs0_3p1:
		vdd_pdphy:
		pp3100_l17a: ldo17 {
			/* TODO: not ppvar, so min/max should be the same */
			regulator-min-microvolt = <2920000>;
			regulator-max-microvolt = <3232000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
		};

		pp1800_pen:
		pp1800_l18a: ldo18 {
			regulator-min-microvolt = <1800000>;
			regulator-max-microvolt = <1800000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
		};

		mcp_vcc:
		pp2850_l19a: ldo19 {
			/* TODO: IDP sets this higher so we'll match */
			regulator-min-microvolt = <2960000>;
			regulator-max-microvolt = <2960000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
		};
	};

	pm6150l-rpmh-regulators {
		compatible = "qcom,pm6150l-rpmh-regulators";
		qcom,pmic-id = "c";

		pp1300_s8c: smps8 {
			/* TODO: not ppvar, so min/max should be the same */
			regulator-min-microvolt = <1120000>;
			regulator-max-microvolt = <1408000>;
		};

		pp1800_l1c: ldo1 {
			regulator-min-microvolt = <1800000>;
			regulator-max-microvolt = <1800000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
		};

		vdd_wcss_adc_dac:
		pp1300_l2c: ldo2 {
			/* TODO: not ppvar, so min/max should be the same */
			regulator-min-microvolt = <1168000>;
			regulator-max-microvolt = <1304000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
		};

		vdd_ufs1_1p2:
		vdda_csi0_1p25:
		vdda_csi1_1p25:
		vdda_csi2_1p25:
		vdda_csi3_1p25:
		vdda_hv_ebi0:
		vdda_mipi_dsi0_1p2:
		vdda_usb_ss_dp_1p2:
		vddpx_10:
		pp1200_l3c: ldo3 {
			regulator-min-microvolt = <1200000>;
			regulator-max-microvolt = <1200000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
		};

		ld_pp1800_esim_l4c:
		vddpx_5:
		pp1800_l4c: ldo4 {
			/* TODO: not ppvar, so min/max should be the same */
			regulator-min-microvolt = <1648000>;
			regulator-max-microvolt = <3304000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
		};

		vddpx_6:
		pp1800_l5c: ldo5 {
			regulator-min-microvolt = <1800000>;
			regulator-max-microvolt = <1800000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
		};

		vddpx_2:
		ppvar_l6c: ldo6 {
			/* TODO: max should probably be 2.95 to match vmmc */
			regulator-min-microvolt = <1800000>;
			regulator-max-microvolt = <3304000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
		};

		pp3300_hub:
		pp3300_l7c: ldo7 {
			regulator-min-microvolt = <3304000>;
			regulator-max-microvolt = <3304000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
			/* TODO: Implement hub driver to turn this off */
			regulator-always-on;
			regulator-boot-on;
		};

		pp1800_brij_vccio:
		pp1800_edp_vpll:
		pp1800_l8c: ldo8 {
			regulator-min-microvolt = <1800000>;
			regulator-max-microvolt = <1800000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
		};

		pp2950_l9c: ldo9 {
			regulator-min-microvolt = <2952000>;
			regulator-max-microvolt = <2952000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
		};

		pp3300_l10c: ldo10 {
			/* TODO: not ppvar, so min/max should be the same */
			regulator-min-microvolt = <3000000>;
			regulator-max-microvolt = <3400000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
		};

		pp3300_l11c: ldo11 {
			/* TODO: not ppvar, so min/max should be the same */
			regulator-min-microvolt = <3000000>;
			regulator-max-microvolt = <3400000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
		};

		src_vreg_bob: bob {
			regulator-min-microvolt = <3008000>;
			regulator-max-microvolt = <3960000>;
			regulator-initial-mode = <RPMH_REGULATOR_MODE_AUTO>;
		};
	};
};

&ap_ec_spi {
	status = "okay";
	cros_ec: ec@0 {
		compatible = "google,cros-ec-spi";
		reg = <0>;
		interrupt-parent = <&tlmm>;
		interrupts = <94 IRQ_TYPE_LEVEL_LOW>;
		pinctrl-names = "default";
		pinctrl-0 = <&ap_ec_int_l>;
		spi-max-frequency = <3000000>;

		cros_ec_pwm: ec-pwm {
			compatible = "google,cros-ec-pwm";
			#pwm-cells = <1>;
		};

		i2c_tunnel: i2c-tunnel {
			compatible = "google,cros-ec-i2c-tunnel";
			google,remote-bus = <0>;
			#address-cells = <1>;
			#size-cells = <0>;
		};

		pdupdate {
			compatible = "google,cros-ec-pd-update";
		};
	};
};

&ap_h1_spi {
	status = "okay";
	cr50: tpm@0 {
		compatible = "google,cr50";
		reg = <0>;
		pinctrl-names = "default";
		pinctrl-0 = <&h1_ap_int_odl>;
		spi-max-frequency = <800000>;
		interrupt-parent = <&tlmm>;
		interrupts = <42 IRQ_TYPE_EDGE_RISING>;
	};
};

&dsi0 {
	status = "okay";
	vdda-supply = <&vdda_mipi_dsi0_1p2>;

	ports {
		port@1 {
			endpoint {
				remote-endpoint = <&sn65dsi86_in>;
				data-lanes = <0 1 2 3>;
			};
		};
	};
};

&dsi_phy {
	status = "okay";
	vdds-supply = <&vdda_mipi_dsi0_pll>;
};

edp_brij_i2c: &i2c2 {
	status = "okay";
	clock-frequency = <400000>;

	sn65dsi86_bridge: bridge@2d {
		compatible = "ti,sn65dsi86";
		reg = <0x2d>;
		pinctrl-names = "default";
		pinctrl-0 = <&edp_brij_en>, <&edp_brij_irq>;

		interrupt-parent = <&tlmm>;
		interrupts = <11 IRQ_TYPE_LEVEL_HIGH>;

		enable-gpios = <&tlmm 14 GPIO_ACTIVE_HIGH>;

		vpll-supply = <&pp1800_edp_vpll>;
		vccio-supply = <&pp1800_brij_vccio>;
		vcca-supply = <&pp1200_brij>;
		vcc-supply = <&pp1200_brij>;

		clocks = <&rpmhcc RPMH_LN_BB_CLK3>;
		clock-names = "refclk";

		ports {
			#address-cells = <1>;
			#size-cells = <0>;

			port@0 {
				reg = <0>;
				sn65dsi86_in: endpoint {
					remote-endpoint = <&dsi0_out>;
				};
			};

			port@1 {
				reg = <1>;
				sn65dsi86_out: endpoint {
					remote-endpoint = <&panel_in_edp>;
				};
			};
		};
	};
};

ap_ts_pen_1v8: &i2c4 {
	status = "okay";
	clock-frequency = <400000>;

	ap_pen: digitizer@9 {
		compatible = "wacom,w9013", "hid-over-i2c";
		reg = <0x9>;
		pinctrl-names = "default";
		pinctrl-0 = <&pen_irq_l>, <&pen_pdct_l>, <&pen_rst_odl>;

		vddl-supply = <&pp1800_pen>;
		post-power-on-delay-ms = <100>;

		interrupt-parent = <&tlmm>;
		interrupts = <21 IRQ_TYPE_LEVEL_LOW>;

		hid-descr-addr = <0x1>; /* TODO: Confirm */
	};

	ap_ts: touchscreen@10 {
		compatible = "elan,ekth3500";
		reg = <0x10>;
		pinctrl-names = "default";
		pinctrl-0 = <&ts_int_l>, <&ts_reset_l>;

		interrupt-parent = <&tlmm>;
		interrupts = <9 IRQ_TYPE_LEVEL_LOW>;

		vcc33-supply = <&pp3300_ts>;

		reset-gpios = <&tlmm 8 GPIO_ACTIVE_LOW>;
	};
};

ap_sar_sensor_i2c: &i2c5 {
	status = "okay";
	clock-frequency = <400000>;
};

ap_tp_i2c: &i2c7 {
	status = "okay";
	clock-frequency = <400000>;

	trackpad@15 {
		compatible = "elan,ekth3000";
		reg = <0x15>;
		pinctrl-names = "default";
		pinctrl-0 = <&trackpad_int_1v8_odl>;

		interrupt-parent = <&tlmm>;
		interrupts = <58 IRQ_TYPE_EDGE_FALLING>;

		vcc-supply = <&pp3300_fp_tp>;

		wakeup-source;
	};
};

hp_i2c: &i2c9 {
	status = "okay";
	clock-frequency = <400000>;

	codec@1a {
		compatible = "realtek,rt5682i";
		reg = <0x1a>;
		pinctrl-names = "default";
		pinctrl-0 = <&hp_irq>;

		interrupt-parent = <&tlmm>;
		interrupts = <28 IRQ_TYPE_LEVEL_HIGH>;

		AVDD-supply = <&pp1800_alc5682>;
		MICVDD-supply = <&pp3300_codec>;
		VBAT-supply = <&pp3300_audio>;

		realtek,dmic1-data-pin = <1>;
		realtek,dmic1-clk-pin = <1>;
		realtek,jd-src = <1>;
	};
};

&mdp {
	status = "okay";
};

&mdss {
	status = "okay";
};

&pm6150_pwrkey {
	status = "disabled";
};

&qupv3_id_0 {
	status = "okay";
};

&qupv3_id_1 {
	status = "okay";
};

&sdhc_1 {
	status = "okay";

	pinctrl-names = "default", "sleep";
	pinctrl-0 = <&sdc1_on>;
	pinctrl-1 = <&sdc1_off>;
	vmmc-supply = <&mcp_vcc>;
	vqmmc-supply = <&mcp_vccq>;
};

&sdhc_2 {
	status = "okay";

	pinctrl-names = "default","sleep";
	pinctrl-0 = <&sdc2_on>;
	pinctrl-1 = <&sdc2_off>;
	vmmc-supply = <&pp2950_l9c>;
	vqmmc-supply = <&ppvar_l6c>;

	cd-gpios = <&tlmm 69 GPIO_ACTIVE_LOW>;
};

ap_spi_fp: &spi10 {
	status = "okay";

	cros_ec_fp: ec@0 {
		compatible = "google,cros-ec-spi";
		reg = <0>;
		interrupt-parent = <&tlmm>;
		interrupts = <4 IRQ_TYPE_LEVEL_LOW>;
		pinctrl-names = "default";
		pinctrl-0 = <&fp_to_ap_irq_l>, <&fp_rst_l>, <&fpmcu_boot0>, <&fpmcu_sel>;
		spi-max-frequency = <3000000>;
	};
};

#include <arm/cros-ec-keyboard.dtsi>
#include <arm/cros-ec-sbs.dtsi>

&uart3 {
	status = "okay";

	bluetooth: bluetooth {
		compatible = "qcom,wcn3991-bt";
		vddio-supply = <&pp1800_l10a>;
		vddxo-supply = <&pp1800_l1c>;
		vddrf-supply = <&pp1300_l2c>;
		vddch0-supply = <&pp3300_l10c>;
		max-speed = <3200000>;
		clocks = <&rpmhcc RPMH_RF_CLK2>;
	};
};

&uart8 {
	status = "okay";
};

&usb_1 {
	status = "okay";
};

&usb_1_dwc3 {
	dr_mode = "host";
};

&usb_1_hsphy {
	status = "okay";
	vdd-supply = <&vdd_qusb_hs0_core>;
	vdda-pll-supply = <&vdda_qusb_hs0_1p8>;
	vdda-phy-dpdm-supply = <&vdda_qusb_hs0_3p1>;
	qcom,imp-res-offset-value = <8>;
	qcom,hstx-trim-value = <QUSB2_V2_HSTX_TRIM_21_6_MA>;
	qcom,preemphasis-level = <QUSB2_V2_PREEMPHASIS_5_PERCENT>;
	qcom,preemphasis-width = <QUSB2_V2_PREEMPHASIS_WIDTH_HALF_BIT>;
};

&usb_1_qmpphy {
	status = "okay";
	vdda-phy-supply = <&vdda_usb_ss_dp_1p2>;
	vdda-pll-supply = <&vdda_usb_ss_dp_core>;
};

/* PINCTRL - additions to nodes defined in sdm845.dtsi */

&qspi_cs0 {
	pinconf {
		pins = "gpio68";
		bias-disable;
	};
};

&qspi_clk {
	pinconf {
		pins = "gpio63";
		bias-disable;
	};
};

&qspi_data01 {
	pinconf {
		pins = "gpio64", "gpio65";

		/* High-Z when no transfers; nice to park the lines */
		bias-pull-up;
	};
};

&qup_i2c2_default {
	pinconf {
		pins = "gpio15", "gpio16";
		drive-strength = <2>;

		/* Has external pullup */
		bias-disable;
	};
};

&qup_i2c4_default {
	pinconf {
		pins = "gpio115", "gpio116";
		drive-strength = <2>;

		/* Has external pullup */
		bias-disable;
	};
};

&qup_i2c5_default {
	pinconf {
		pins = "gpio25", "gpio26";
		drive-strength = <2>;

		/* Has external pullup */
		bias-disable;
	};
};

&qup_i2c7_default {
	pinconf {
		pins = "gpio6", "gpio7";
		drive-strength = <2>;

		/* Has external pullup */
		bias-disable;
	};
};

&qup_i2c9_default {
	pinconf {
		pins = "gpio46", "gpio47";
		drive-strength = <2>;

		/* Has external pullup */
		bias-disable;
	};
};

&qup_spi0_default {
	pinconf {
		pins = "gpio34", "gpio35", "gpio36", "gpio37";
		drive-strength = <2>;
		bias-disable;
	};
};

&qup_spi6_default {
	pinconf {
		pins = "gpio59", "gpio60", "gpio61", "gpio62";
		drive-strength = <2>;
		bias-disable;
	};
};

&qup_spi10_default {
	pinconf {
		pins = "gpio86", "gpio87", "gpio88", "gpio89";
		drive-strength = <2>;
		bias-disable;
	};
};

&qup_uart3_default {
	pinconf-cts {
		/*
		 * Configure a pull-down on CTS to match the pull of
		 * the Bluetooth module.
		 */
		pins = "gpio38";
		bias-pull-down;
	};

	pinconf-rts-tx {
		/* We'll drive RTS and TX, so no pull */
		pins = "gpio39", "gpio40";
		drive-strength = <2>;
		bias-disable;
	};

	pinconf-rx {
		/*
		 * Configure a pull-up on RX. This is needed to avoid
		 * garbage data when the TX pin of the Bluetooth module is
		 * in tri-state (module powered off or not driving the
		 * signal yet).
		 */
		pins = "gpio41";
		bias-pull-up;
	};
};

&qup_uart8_default {
	pinconf-tx {
		pins = "gpio44";
		drive-strength = <2>;
		bias-disable;
	};

	pinconf-rx {
		pins = "gpio45";
		drive-strength = <2>;
		bias-pull-up;
	};
};

/* PINCTRL - board-specific pinctrl */

&pm6150_gpio {
	status = "disabled"; /* No GPIOs are connected */
};

&pm6150l_gpio {
	gpio-line-names = "AP_SUSPEND", /* TODO: Remove if doesn't work */
			  "",
			  "",
			  "",
			  "",
			  "",
			  "",
			  "",
			  "",
			  "",
			  "",
			  "";
};

&tlmm {
	/*
	 * pinctrl settings for pins that have no real owners.
	 */
	pinctrl-names = "default";
	pinctrl-0 = <&bios_flash_wp_l>, <&ap_suspend_l_neuter>;

	ap_ec_int_l: ap-ec-int-l {
		pinmux {
			pins = "gpio94";
			function = "gpio";
			input-enable;
		};

		pinconf {
			pins = "gpio94";
			bias-pull-up;
		};
	};

	ap_edp_bklten: ap-edp-bklten {
		pinmux {
			pins = "gpio12";
			function = "gpio";
		};

		pinconf {
			pins = "gpio12";
			drive-strength = <2>;
			bias-disable;
		};
	};

	/* We will totally remove this in r2+ */
	ap_suspend_l_neuter: ap-suspend-l-neuter {
		pinmux  {
			pins = "gpio27";
			function = "gpio";
		};

		pinconf {
			pins = "gpio27";
			bias-disable;
		};
	};

	bios_flash_wp_l: bios-flash-wp-l {
		pinmux {
			pins = "gpio42";
			function = "gpio";
			input-enable;
		};

		pinconf {
			pins = "gpio42";
			bias-disable;
		};
	};

	brij_pp1200_en: brij-pp1200-en {
		pinmux {
			pins = "gpio30";
			function = "gpio";
		};

		pinconf {
			pins = "gpio30";
			drive-strength = <2>;
			bias-disable;
		};

	};

	edp_brij_en: edp-brij-en {
		pinmux {
			pins = "gpio104";
			function = "gpio";
		};

		pinconf {
			pins = "gpio104";
			drive-strength = <2>;
			bias-disable;
		};
	};

	edp_brij_irq: edp-brij-irq {
		pinmux {
			pins = "gpio11";
			function = "gpio";
		};

		pinconf {
			pins = "gpio11";
			drive-strength = <2>;
			bias-pull-down;
		};
	};

	en_pp3300_codec: en-pp3300-codec {
		pinmux {
			pins = "gpio83";
			function = "gpio";
		};

		pinconf {
			pins = "gpio83";
			drive-strength = <2>;
			bias-disable;
		};
	};

	en_pp3300_dx_edp: en-pp3300-dx-edp {
		pinmux {
			pins = "gpio106";
			function = "gpio";
		};

		pinconf {
			pins = "gpio106";
			drive-strength = <2>;
			bias-disable;
		};
	};

	fpmcu_boot0: fpmcu-boot0 {
		pinmux {
			pins = "gpio10";
			function = "gpio";
		};

		pinconf {
			pins = "gpio10";
			bias-disable;
			drive-strength = <2>;
			output-low;
		};
	};

	fpmcu_sel: fpmcu-sel {
		pinmux {
			pins = "gpio22";
			function = "gpio";
		};

		pinconf {
			pins = "gpio22";
			bias-disable;
			drive-strength = <2>;
			output-high;
		};
	};

	fp_rst_l: fp-rst-l {
		pinmux {
			pins = "gpio5";
			function = "gpio";
		};

		pinconf {
			pins = "gpio5";
			bias-disable;
			drive-strength = <2>;
			output-high;
		};
	};

	fp_to_ap_irq_l: fp-to-ap-irq-l {
		pinmux {
			pins = "gpio4";
			function = "gpio";
			input-enable;
		};

		pinconf {
			pins = "gpio4";

			/* Has external pullup */
			bias-disable;
		};
	};


	h1_ap_int_odl: h1-ap-int-odl {
		pinmux {
			pins = "gpio42";
			function = "gpio";
			input-enable;
		};

		pinconf {
			pins = "gpio42";
			bias-pull-up;
		};
	};

	hp_irq: hp-irq {
		pinmux {
			pins = "gpio28";
			function = "gpio";
		};

		pinconf {
			pins = "gpio28";
			/* TODO: confirm we want internal pull down */
			bias-pull-down;
		};
	};

	pen_irq_l: pen-irq-l {
		pinmux {
			pins = "gpio21";
			function = "gpio";
		};

		pinconf {
			pins = "gpio21";

			/* Has external pullup */
			bias-disable;
		};
	};

	pen_pdct_l: pen-pdct-l {
		pinmux {
			pins = "gpio52";
			function = "gpio";
		};

		pinconf {
			pins = "gpio52";

			/* Has external pullup */
			bias-disable;
		};
	};

	pen_rst_odl: pen-rst-odl {
		pinmux  {
			pins = "gpio18";
			function = "gpio";
		};

		pinconf {
			pins = "gpio18";
			bias-disable;
			drive-strength = <2>;

			/*
			 * The pen driver doesn't currently support
			 * driving this reset line.  By specifying
			 * output-high here we're relying on the fact
			 * that this pin has a default pulldown at boot
			 * (which makes sure the pen was in reset if it
			 * was powered) and then we set it high here to
			 * take it out of reset.  Better would be if the
			 * pen driver could control this and we could
			 * remove "output-high" here.
			 */
			output-high; /* TODO: Remove this? */
		};
	};

	trackpad_int_1v8_odl: trackpad-int-1v8-odl {
		pinmux {
			pins = "gpio58";
			function = "gpio";
		};

		pinconf {
			pins = "gpio58";

			/* Has external pullup */
			bias-disable;
		};
	};

	ts_int_l: ts-int-l {
		pinmux  {
			pins = "gpio9";
			function = "gpio";
		};

		pinconf {
			pins = "gpio9";
			bias-pull-up;
		};
	};

	ts_reset_l: ts-reset-l {
		pinmux  {
			pins = "gpio8";
			function = "gpio";
		};

		pinconf {
			pins = "gpio8";
			bias-disable;
			drive-strength = <2>;
		};
	};
};
